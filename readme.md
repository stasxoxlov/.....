1. Сортировка выбором (Java)

Объяснение работы:
- Внешний цикл `for (int i = 0; i < arr.length - 1; i++)` - проходит по всем элементам массива
- Внутренний цикл `for (int j = i + 1; j < arr.length; j++)` - ищет минимальный элемент в неотсортированной части
- Условный оператор `if (arr[j] < arr[minIndex])` - сравнивает элементы для нахождения минимума
- Обмен элементов `int temp = arr[minIndex]...` - меняет местами текущий элемент с найденным минимальным

Временная сложность: O(n²) во всех случаях

Ввод:

Исходный массив: 64 25 12 22 11


Вывод:

Отсортированный массив: 11 12 22 25 64


 2. Сортировка пузырьком (Python)

Объяснение работы:
- Внешний цикл `for i in range(n-1)` - определяет количество проходов
- Внутренний цикл `for j in range(0, n-i-1)` - сравнивает соседние элементы
- Условие `if arr[j] > arr[j+1]` - проверяет правильность порядка элементов
- Обмен `arr[j], arr[j+1] = arr[j+1], arr[j]` - меняет элементы местами при неправильном порядке

Временная сложность: 
- Лучший случай: O(n) (уже отсортирован)
- Средний и худший: O(n²)

Ввод:

Исходный массив: [64, 34, 25, 12, 22, 11, 90]


Вывод:

Отсортированный массив: [11, 12, 22, 25, 34, 64, 90]


 3. Сортировка вставками (C++)

Объяснение работы:
- Цикл `for (int i = 1; i < arr.size(); i++)` - берет каждый следующий элемент для вставки
- Переменная `int key = arr[i]` - сохраняет текущий элемент для вставки
- Цикл `while (j >= 0 && arr[j] > key)` - сдвигает элементы больше key вправо
- Присваивание `arr[j + 1] = key` - вставляет элемент на правильную позицию

Временная сложность:
- Лучший случай: O(n)
- Средний и худший: O(n²)

Ввод:

Исходный массив: 12 11 13 5 6


Вывод:

Отсортированный массив: 5 6 11 12 13


 4. Сортировка слиянием (Java)

Объяснение работы:
- Базовый случай `if (arr.length <= 1)` - остановка рекурсии
- Разделение `Arrays.copyOfRange(arr, 0, mid)` - делит массив на две части
- Рекурсивные вызовы `mergeSort(left)` и `mergeSort(right)` - сортируют половинки
- Функция `merge()` - объединяет отсортированные части

Временная сложность: O(n log n) во всех случаях

Ввод:

Исходный массив: [38, 27, 43, 3, 9, 82, 10]


Вывод:

Отсортированный массив: [3, 9, 10, 27, 38, 43, 82]


 5. Сортировка Шелла (Python)

Объяснение работы:
- Цикл `while gap > 0` - уменьшает шаг до 1
- Цикл `for i in range(gap, n)` - проходит по элементам с текущим шагом
- Цикл `while j >= gap and arr[j - gap] > temp` - выполняет сортировку вставками внутри подмассивов
- Присваивание `arr[j] = temp` - вставляет элемент на правильное место

Временная сложность:
- Лучший: O(n log n)
- Средний: O(n^(3/2))
- Худший: O(n²)

Ввод:

Исходный массив: [12, 34, 54, 2, 3]


Вывод:

Отсортированный массив: [2, 3, 12, 34, 54]


 6. Быстрая сортировка (C++)

Объяснение работы:
- Функция `partition()` - выбирает опорный элемент и перераспределяет элементы
- Опорный элемент `int pivot = arr[high]` - последний элемент как опора
- Цикл `for (int j = low; j < high; j++)` - сравнивает элементы с опорным
- Рекурсивные вызовы `quickSort(arr, low, pi - 1)` - сортирует левую и правую части

Временная сложность:
- Лучший и средний: O(n log n)
- Худший: O(n²)

Ввод:

Исходный массив: 10 7 8 9 1 5


Вывод:

Отсортированный массив: 1 5 7 8 9 10


 7. Пирамидальная сортировка (Java)

Объяснение работы:
- Построение кучи `for (int i = n / 2 - 1; i >= 0; i--)` - создает max-heap из массива
- Функция `heapify()` - поддерживает свойства кучи
- Извлечение элементов `for (int i = n - 1; i > 0; i--)` - извлекает максимальный элемент в конец
- Обмен `int temp = arr[0]` - перемещает корень в отсортированную часть

Временная сложность: O(n log n) во всех случаях

Ввод:

Исходный массив: [12, 11, 13, 5, 6, 7]


Вывод:

Отсортированный массив: [5, 6, 7, 11, 12, 13]


 8. Линейный поиск (Python)

Объяснение работы:
- Цикл `for i in range(len(arr))` - последовательно проверяет каждый элемент
- Условие `if arr[i] == target` - сравнивает текущий элемент с искомым
- Оператор `return i` - возвращает индекс при нахождении
- Оператор `return -1` - возвращает -1 если элемент не найден

Временная сложность: O(n)

Ввод:

Массив: [3, 5, 2, 7, 9, 1, 4]
Искомый элемент: 7


Вывод:

Элемент найден на позиции: 3


 9. Бинарный поиск (C++)

Объяснение работы:
- Цикл `while (left <= right)` - продолжает пока есть элементы для проверки
- Вычисление середины `int mid = left + (right - left) / 2` - находит средний элемент
- Сравнение `if (arr[mid] == target)` - проверяет совпадение
- Корректировка границ `right = mid - 1` или `left = mid + 1` - сужает область поиска

Временная сложность: O(log n)

Ввод:

Отсортированный массив: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]
Искомый элемент: 7


Вывод:

Элемент найден на позиции: 3


 10. Интерполяционный поиск (Java)

Объяснение работы:
- Формула позиции `lo + (((hi - lo) * (x - arr[lo])) / (arr[hi] - arr[lo]))` - предсказывает позицию элемента
- Рекурсивные вызовы - сужают область поиска влево или вправо
- Проверка границ `if (lo <= hi && x >= arr[lo] && x <= arr[hi])` - гарантирует валидность поиска

Временная сложность:
- Лучший: O(log log n)
- Худший: O(n)

Ввод:

Массив: [10, 12, 13, 16, 18, 19, 20, 21, 22, 23, 24, 33, 35, 42, 47]
Искомый элемент: 18


Вывод:

Элемент найден на позиции: 4


 11. Поиск Фибоначчи (Python)

Объяснение работы:
- Генерация чисел Фибоначчи `while fib_m < n` - находит подходящую последовательность
- Вычисление индекса `min(offset + fib_m2, n - 1)` - определяет позицию для сравнения
- Корректировка чисел Фибоначчи - сужает область поиска
- Проверка последнего элемента - обрабатывает граничный случай

Временная сложность: O(log n)

Ввод:

Массив: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100]
Искомый элемент: 85
