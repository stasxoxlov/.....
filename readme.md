 1. Сортировка выбором (Selection Sort) - Java

Определение: Алгоритм сортировки, который на каждом шаге находит минимальный элемент в неотсортированной части массива и помещает его в начало.

Объяснение работы:
- Внешний цикл `for (int i = 0; i < arr.length - 1; i++)` - последовательно перебирает все позиции массива
- Инициализация `int minIndex = i` - предполагаем, что текущий элемент минимальный
- Внутренний цикл `for (int j = i + 1; j < arr.length; j++)` - ищет реальный минимальный элемент в оставшейся части
- Сравнение `if (arr[j] < arr[minIndex])` - если нашли элемент меньше текущего минимума
- Обмен `int temp = arr[minIndex]...` - меняем местами найденный минимум с текущей позицией

Временная сложность:
- Лучший случай: O(n²) - даже если массив отсортирован, все равно делаем полные проходы
- Средний случай: O(n²) - в среднем требуется n²/2 сравнений
- Худший случай: O(n²) - максимальное количество сравнений

Пример работы:

Ввод: [64, 25, 12, 22, 11]
Шаг 1: [11, 25, 12, 22, 64]  // найден минимум 11
Шаг 2: [11, 12, 25, 22, 64]  // найден минимум 12
Шаг 3: [11, 12, 22, 25, 64]  // найден минимум 22
Вывод: [11, 12, 22, 25, 64]


 2. Сортировка пузырьком (Bubble Sort) - Python

Определение: Алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами при неправильном порядке.

Объяснение работы:
- Внешний цикл `for i in range(n-1)` - определяет количество проходов (n-1)
- Внутренний цикл `for j in range(0, n-i-1)` - на каждом проходе проверяет пары элементов
- Сравнение `if arr[j] > arr[j+1]` - если левый элемент больше правого
- Обмен `arr[j], arr[j+1] = arr[j+1], arr[j]` - меняет элементы местами

Временная сложность:
- Лучший случай: O(n) - если массив уже отсортирован (с флагом оптимизации)
- Средний случай: O(n²) - в среднем требуется n²/2 сравнений
- Худший случай: O(n²) - если массив отсортирован в обратном порядке

Пример работы:

Ввод: [5, 1, 4, 2, 8]
Проход 1: [1, 4, 2, 5, 8]  // 5>1, 4>2, 5>2
Проход 2: [1, 2, 4, 5, 8]  // 4>2
Вывод: [1, 2, 4, 5, 8]


 3. Сортировка вставками (Insertion Sort) - C++

Определение: Алгоритм, который строит отсортированный массив по одному элементу за раз, вставляя каждый новый элемент в правильную позицию.

Объяснение работы:
- Цикл `for (int i = 1; i < arr.size(); i++)` - начинаем со второго элемента
- Ключ `int key = arr[i]` - сохраняем текущий элемент для вставки
- Индекс `int j = i - 1` - начинаем сравнение с предыдущим элементом
- Сдвиг `while (j >= 0 && arr[j] > key)` - сдвигаем элементы больше ключа вправо
- Вставка `arr[j + 1] = key` - вставляем ключ на правильную позицию

Временная сложность:
- Лучший случай: O(n) - когда массив уже отсортирован
- Средний случай: O(n²) - в среднем n²/4 сравнений
- Худший случай: O(n²) - когда массив отсортирован в обратном порядке

Пример работы:

Ввод: [12, 11, 13, 5, 6]
Шаг 1: [11, 12, 13, 5, 6]  // вставили 11
Шаг 2: [11, 12, 13, 5, 6]  // 13 уже на месте
Шаг 3: [5, 11, 12, 13, 6]  // вставили 5
Шаг 4: [5, 6, 11, 12, 13]  // вставили 6
Вывод: [5, 6, 11, 12, 13]


 4. Сортировка слиянием (Merge Sort) - Java

Определение: Рекурсивный алгоритм "разделяй и властвуй", который делит массив пополам, сортирует каждую половину и объединяет их.

Объяснение работы:
- Базовый случай `if (arr.length <= 1)` - массивы из 0 или 1 элемента уже отсортированы
- Разделение `int mid = arr.length / 2` - находим середину массива
- Рекурсия `mergeSort(left)` и `mergeSort(right)` - сортируем левую и правую части
- Слияние `merge(left, right)` - объединяем отсортированные части

Временная сложность:
- Лучший случай: O(n log n)
- Средний случай: O(n log n)
- Худший случай: O(n log n)

Пример работы:

Ввод: [38, 27, 43, 3, 9, 82, 10]
Делим: [38,27,43] [3,9,82,10]
Делим: [38] [27,43] [3,9] [82,10]
Сливаем: [27,38,43] [3,9,10,82]
Сливаем: [3,9,10,27,38,43,82]
Вывод: [3, 9, 10, 27, 38, 43, 82]


 5. Сортировка Шелла (Shell Sort) - Python

Определение: Улучшенная версия сортировки вставками, которая сортирует элементы на определенном расстоянии друг от друга.

Объяснение работы:
- Шаг `gap = n // 2` - начинаем с большого расстояния
- Цикл `while gap > 0` - уменьшаем шаг до 1
- Вставки `for i in range(gap, n)` - сортируем элементы с шагом gap
- Сдвиг `while j >= gap and arr[j - gap] > temp` - сдвигаем элементы

Временная сложность:
- Лучший случай: O(n log n)
- Средний случай: O(n^(3/2))
- Худший случай: O(n²)

Пример работы:

Ввод: [12, 34, 54, 2, 3]
Шаг 3: [12, 34, 54, 2, 3] → [2, 34, 54, 12, 3] → [2, 3, 54, 12, 34]
Шаг 1: [2, 3, 12, 34, 54]
Вывод: [2, 3, 12, 34, 54]


 6. Быстрая сортировка (Quick Sort) - C++

Определение: Алгоритм "разделяй и властвуй", который выбирает опорный элемент и разделяет массив на элементы меньше и больше опорного.

Объяснение работы:
- Выбор опоры `int pivot = arr[high]` - последний элемент как опора
- Разделение `partition()` - перераспределяет элементы относительно опоры
- Рекурсия `quickSort(arr, low, pi - 1)` - сортирует левую часть
- Рекурсия `quickSort(arr, pi + 1, high)` - сортирует правую часть

Временная сложность:
- Лучший случай: O(n log n)
- Средний случай: O(n log n)
- Худший случай: O(n²) - когда опора всегда минимальный или максимальный элемент

Пример работы:

Ввод: [10, 7, 8, 9, 1, 5]
Опора 5: [1, 5, 8, 9, 10, 7]
Опора 1: [1] | Опора 7: [7, 8, 9, 10]
Вывод: [1, 5, 7, 8, 9, 10]


 7. Пирамидальная сортировка (Heap Sort) - Java

Определение: Алгоритм, который использует структуру данных "куча" для сортировки элементов.

Объяснение работы:
- Построение кучи `for (int i = n/2-1; i>=0; i--)` - преобразует массив в max-heap
- Извлечение `for (int i = n-1; i>0; i--)` - извлекает максимальный элемент
- Heapify `heapify(arr, n, i)` - поддерживает свойства кучи

Временная сложность: O(n log n) во всех случаях

Пример работы:

Ввод: [12, 11, 13, 5, 6, 7]
Построение кучи: [13, 11, 12, 5, 6, 7]
Извлечение: [12, 11, 7, 5, 6, 13]
Извлечение: [11, 6, 7, 5, 12, 13]
Вывод: [5, 6, 7, 11, 12, 13]


 8. Линейный поиск (Linear Search) - Python

Определение: Простейший алгоритм поиска, который последовательно проверяет каждый элемент массива.

Объяснение работы:
- Цикл `for i in range(len(arr))` - перебирает все элементы
- Сравнение `if arr[i] == target` - проверяет совпадение
- Возврат `return i` - возвращает индекс при нахождении

Временная сложность: O(n)

Пример работы:

Ввод: массив = [2, 5, 8, 12, 16], target = 12
Сравнение: 2≠12, 5≠12, 8≠12, 12=12
Вывод: Элемент найден на позиции 3


 9. Бинарный поиск (Binary Search) - C++

Определение: Эффективный алгоритм поиска в отсортированном массиве, который делит область поиска пополам на каждом шаге.

Объяснение работы:
- Границы `left = 0, right = n-1` - начальные границы поиска
- Середина `mid = left + (right-left)/2` - находим средний элемент
- Сравнение `arr[mid] == target` - проверяем совпадение
- Сужение `right = mid-1` или `left = mid+1` - сужаем область поиска

Временная сложность: O(log n)

Пример работы:

Ввод: [1, 3, 5, 7, 9, 11], target = 7
Шаг 1: mid=5 (элемент 7) → найдено
Вывод: Элемент найден на позиции 3


 10. Интерполяционный поиск (Interpolation Search) - Java

Определение: Улучшенный бинарный поиск, который предсказывает позицию элемента на основе значений.

Объяснение работы:
- Формула позиции - вычисляет вероятную позицию элемента
- Рекурсия - сужает область поиска влево или вправо

Временная сложность:
- Лучший случай: O(log log n)
- Худший случай: O(n)

Пример работы:

Ввод: [10, 12, 13, 16, 18], target = 16
Позиция = 0 + ((4-0)*(16-10))/(18-10) = 3
Вывод: Элемент найден на позиции 3


 11. Поиск Фибоначчи (Fibonacci Search) - Python

Определение: Алгоритм поиска, использующий числа Фибоначчи для определения позиций сравнения.

Объяснение работы:
- Генерация чисел Фибоначчи - находит последовательность
- Определение позиций - использует числа Фибоначчи для индексов
- Сравнение и сужение - корректирует область поиска

Временная сложность: O(log n)

Пример работы:

Ввод: [10, 22, 35, 40, 45, 50, 80, 82, 85, 90, 100], target = 85
Числа Фибоначчи: 0,1,1,2,3,5,8,13
Поиск: сравниваем с элементами на позициях 5,8
Вывод: Элемент найден на позиции 8
